# -*- coding: utf-8 -*-
"""Projeto de detecção.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1pHYd4Y1VNiPGilUZXYRvzT09FXwphOby

Instalação de Bibliotecas
"""

pip install pandas numpy scikit-learn matplotlib seaborn

"""Upload dos dados"""

import pandas as pd

# Substitua 'creditcard.csv' pelo nome real do arquivo CSV do seu dataset
try:
    df = pd.read_csv('creditcard.csv')
    print("Dataset carregado com sucesso!")
except FileNotFoundError:
    print("Erro: Arquivo 'creditcard.csv' não encontrado. Verifique o caminho do arquivo.")
    # Verifique se o nome do arquivo está correto ou se o arquivo está na pasta certa.

"""Primeira Visualização e Entendimento Rápido (O Início da EDA):"""

# Mostra as primeiras 5 linhas do DataFrame
print("\nPrimeiras 5 linhas do dataset:")
print(df.head())

# Mostra informações sobre as colunas (tipos de dados, valores não nulos)
print("\nInformações do dataset:")
df.info()

# Mostra estatísticas descritivas das colunas numéricas
print("\nEstatísticas descritivas do dataset:")
print(df.describe())

# Mostra o número de linhas e colunas
print("\nFormato do dataset (linhas, colunas):")
print(df.shape)

# Verifica a quantidade de valores nulos por coluna
print("\nValores nulos por coluna:")
print(df.isnull().sum())

"""Análise Exploratória de Dados (EDA):

Nesta etapa, o objetivo é investigar, resumir e visualizar os dados para descobrir insights e preparar o terreno para a modelagem.
Entender a Distribuição da Classe Alvo (Fraude vs. Não-Fraude)
Este é o ponto mais crítico para um projeto de detecção de fraudes, pois as fraudes são eventos raros.
Verifique a contagem de cada classe: Use o método value_counts()na sua coluna alvo (geralmente chamada de 'Classe' ou 'Fraude').
Calcule a porcentagem: É importante ver o quão desequilibrada a proporção é.
"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# Supondo que seu DataFrame seja 'df' e a coluna alvo seja 'Class'
# Se o seu dataset for o de Credit Card Fraud Detection do Kaggle, a coluna é 'Class'

print("Contagem de classes na coluna 'Class':")
print(df['Class'].value_counts())

print("\nPorcentagem de classes na coluna 'Class':")
print(df['Class'].value_counts(normalize=True) * 100)

# Visualização da distribuição da classe alvo
plt.figure(figsize=(6, 4))
sns.countplot(x='Class', data=df)
plt.title('Distribuição da Classe (0: Não Fraude, 1: Fraude)')
plt.xlabel('Classe')
plt.ylabel('Número de Transações')
plt.xticks(ticks=[0, 1], labels=['Não Fraude', 'Fraude'])
plt.show()

"""Análise de Variáveis ​​Numéricas Chave ('Valor' e 'Tempo')"""

# Estatísticas descritivas para 'Amount' separadas por classe
print("\nEstatísticas descritivas de 'Amount' para transações NÃO FRAUDULENTAS:")
print(df[df['Class'] == 0]['Amount'].describe())

print("\nEstatísticas descritivas de 'Amount' para transações FRAUDULENTAS:")
print(df[df['Class'] == 1]['Amount'].describe())

# Box plot para comparar a distribuição de 'Amount'
plt.figure(figsize=(10, 6))
sns.boxplot(x='Class', y='Amount', data=df, showfliers=False) # showfliers=False para não mostrar outliers extremos (para melhor visualização da massa de dados)
plt.title('Distribuição de Valor (Amount) por Classe')
plt.xlabel('Classe')
plt.ylabel('Valor da Transação')
plt.xticks(ticks=[0, 1], labels=['Não Fraude', 'Fraude'])
plt.ylim(0, 500) # Limite para visualizar melhor a maioria dos dados
plt.show()

# Histograma da coluna 'Amount' para as duas classes
plt.figure(figsize=(12, 5))
plt.subplot(1, 2, 1)
sns.histplot(df[df['Class'] == 0]['Amount'], bins=50, kde=True, color='blue')
plt.title('Distribuição de Valor (Não Fraude)')
plt.xlabel('Valor')
plt.ylabel('Frequência')

plt.subplot(1, 2, 2)
sns.histplot(df[df['Class'] == 1]['Amount'], bins=50, kde=True, color='red')
plt.title('Distribuição de Valor (Fraude)')
plt.xlabel('Valor')
plt.ylabel('Frequência')
plt.tight_layout()
plt.show()

"""Tempo da Transação"""

# Convertendo 'Time' para horas do dia (se o dataset for o do Kaggle)
# 'Time' está em segundos, então dividimos por 3600 (segundos em uma hora) e usamos o módulo 24
df['Hour'] = df['Time'].apply(lambda x: x / 3600 % 24)

plt.figure(figsize=(12, 6))
sns.histplot(df[df['Class'] == 0]['Hour'], bins=48, kde=True, color='blue', alpha=0.7, label='Não Fraude')
sns.histplot(df[df['Class'] == 1]['Hour'], bins=48, kde=True, color='red', alpha=0.7, label='Fraude')
plt.title('Distribuição de Transações por Hora do Dia')
plt.xlabel('Hora do Dia (0-23)')
plt.ylabel('Número de Transações')
plt.legend()
plt.show()

"""Análise dos Componentes Principais (Recursos V1-V28)"""

# Exemplo para algumas colunas V - você pode iterar por todas as 28
features_v = ['V1', 'V2', 'V3', 'V4', 'V5', 'V6', 'V7', 'V8', 'V9', 'V10'] # Escolha algumas para começar

plt.figure(figsize=(16, 12))
for i, feature in enumerate(features_v):
    plt.subplot(4, 3, i + 1)
    sns.boxplot(x='Class', y=feature, data=df, showfliers=False) # showfliers=False para melhor visualização
    plt.title(f'Distribuição de {feature} por Classe')
    plt.xlabel('Classe')
    plt.ylabel(feature)
plt.tight_layout()
plt.show()

# Para uma análise mais sistemática, você pode usar violin plots ou kdeplots
# para ver a densidade da distribuição para cada classe.
# Exemplo para V1 e V2
plt.figure(figsize=(14, 6))
plt.subplot(1, 2, 1)
sns.kdeplot(df[df['Class'] == 0]['V1'], label='Não Fraude', color='blue', fill=True)
sns.kdeplot(df[df['Class'] == 1]['V1'], label='Fraude', color='red', fill=True)
plt.title('Distribuição de V1 por Classe')
plt.legend()

plt.subplot(1, 2, 2)
sns.kdeplot(df[df['Class'] == 0]['V2'], label='Não Fraude', color='blue', fill=True)
sns.kdeplot(df[df['Class'] == 1]['V2'], label='Fraude', color='red', fill=True)
plt.title('Distribuição de V2 por Classe')
plt.legend()
plt.tight_layout()
plt.show()

"""Análise de Correlação (Entre Features e com a Classe Alvo)

"""

# Calcula a matriz de correlação
corr_matrix = df.corr()

# Plota um mapa de calor da matriz de correlação
plt.figure(figsize=(20, 18))
sns.heatmap(corr_matrix, cmap='coolwarm', fmt=".2f", linewidths=.5)
plt.title('Matriz de Correlação de Todas as Features')
plt.show()

# Correlação com a classe alvo
print("\nCorrelação das features com a classe alvo ('Class'):")
print(corr_matrix['Class'].sort_values(ascending=False))

